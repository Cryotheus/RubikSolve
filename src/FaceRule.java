// instructions for how to rotate a face of the cube
public class FaceRule {

	// the faces adjacent to this face, ordered
	public int[] AdjacentFaceOrder;

	// the bit-packed strip ints
	// this is used to identify the rows and columns that are cycled
	// obeys the order of AdjacentFaceOrder
	public int[] AdjacentFaceStrips;

	// clockwise face rotation
	public boolean Clockwise = true;

	public static FaceRule[] MOVEMENTS = {
		new FaceRule(new int[]{4, 3, 2, 1}, new int[]{0b00_01, 0b00_01, 0b00_01, 0b00_01}), //MV_UP
		new FaceRule(new int[]{0, 2, 5, 4}, new int[]{0b00_10, 0b00_10, 0b00_10, 0b11_01}), //MV_LEFT
		new FaceRule(new int[]{0, 3, 5, 1}, new int[]{0b10_11, 0b00_10, 0b01_00, 0b11_01}), //MV_FRONT
		new FaceRule(new int[]{4, 5, 2, 0}, new int[]{0b00_10, 0b11_01, 0b11_01, 0b11_01}), //MV_RIGHT
		new FaceRule(new int[]{1, 5, 3, 0}, new int[]{0b00_10, 0b11_10, 0b11_01, 0b10_11}), //MV_BACK
		new FaceRule(new int[]{1, 2, 3, 4}, new int[]{0b10_11, 0b10_11, 0b10_11, 0b10_11}), //MV_DOWN

		//new FaceRule(new int[]{1, 5, 3, 0}, new int[]{0b01_11, 0b00_01, 0b10_00, 0b11_10}), //MV_FRONT_PRIME
		//new FaceRule(new int[]{0, 3, 5, 1}, new int[]{0b10_11, 0b00_10, 0b01_00, 0b11_01}), //MV_FRONT

		//for indexat 0b0_110 and 0b0_111 - the two moves that don't exist!
		null,
		null,

		//for the prime movements
		//generated by `createInverseRules`
		null,
		null,
		null,
		null,
		null,
		null,
	};

	public FaceRule(int[] faceOrder, int[] rotationStrips) {
		AdjacentFaceOrder = faceOrder;
		AdjacentFaceStrips = rotationStrips;
	}

	public FaceRule(int[] faceOrder, int[] rotationStrips, boolean clockwise) {
		AdjacentFaceOrder = faceOrder;
		AdjacentFaceStrips = rotationStrips;
		Clockwise = clockwise;
	}

	//replaces the null refs in MOVEMENTS with the proper prime moves
	public static void createInverseRules() {
		for (int i = 0; i < 6; i++) {
			//see comments inside MOVEMENTS
			MOVEMENTS[i | 0b1_000] = MOVEMENTS[i].inverse();
		}
	}

	// creates a new instance which is the exact opposite rule
	//
	// this new instance applies the opposite move,
	// effectively undoing the current intance's move
	public FaceRule inverse() {
		int length = AdjacentFaceOrder.length;
		int[] newFaceOrder = new int[4];
		int[] newRotationStrips = new int[4];

		for (int i = 0; i < length; i++) {
			int rev = length - i - 1;

			//we need to swap the strip's start and end bits as well
			int strip = AdjacentFaceStrips[rev];
			int endCorner = strip & 0b11;
			int startCorner = strip >> 2;

			newFaceOrder[i] = AdjacentFaceOrder[rev];
			newRotationStrips[i] = (endCorner << 2) | startCorner;
		}

		return new FaceRule(newFaceOrder, newRotationStrips, !Clockwise);
	}
}
